import { NextResponse } from "next/server"; // Import NextResponse for API responses

interface MetaData {
    environment: string;
    platformId: string;
}

interface LogoImage {
    key: null;
    props: Record<string, string>;
    _owner: string;
    _store: Record<string, string>;
}

interface Credentials {
    publicKey: string;
    secretKey: string;
    logo: LogoImage;
    additionalMetadata: MetaData;
}

interface VideoConfig {
    encodingTier: string;
    playbackPolicy: Array<string>;
}

interface PlatformCredentials {
    id: string;
    name: string;
    credentials: Credentials;
    config?: VideoConfig;
}

const createMedia = async (
    destinationPlatform: PlatformCredentials,
    playbackId: string,
    mp4_support: string,
    videoId: string,
    source_url: string | null = null
) => {
    const credentials = destinationPlatform?.credentials || null;
    const url = "https://v1.fastpix.io/on-demand";

    const config = destinationPlatform?.config || {};
    const autoGeneratedCaptions = config?.autoGenerateCaptions === "1";
    const maxResolutionTier = config?.maxResolutionTier || null;
    const playbackPolicy = config?.playbackPolicy?.length === 1 ? "public" : "private";
    const testMode = config?.testMode || null;

    const requestBody = {
        metadata: {
            muxMediaId: videoId,
        },
        accessPolicy: playbackPolicy,
        maxResolution: maxResolutionTier,
        inputs: [
            {
                type: "video",
                url: source_url,
                ...(testMode === "1" ? { startTime: 0, endTime: 10 } : {}),
            },
        ],
        mp4Support: "capped_4k",
    };

    try {
        const response = await fetch(url, {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                Authorization:
                    "Basic " +
                    Buffer.from(
                        `${credentials?.publicKey}:${credentials?.secretKey}`
                    ).toString("base64"),
            },
            body: JSON.stringify(requestBody),
        });

        if (response.ok) {
            const res = await response.json();
            return { success: true, response: res };
        } else {
            return { success: false, message: "Failed to create media" };
        }
    } catch (error) {
        return { success: false, message: "Failed to create media" };
    }
};

export async function POST(request: Request) {
    const { videoIds, sourcePlatform, destinationPlatform } = await request.json();
    const credentials = sourcePlatform?.credentials || null;

    try {
        const createdMedia = [];

        for (const videoId of videoIds) {
            const response = await fetch(
                `https://api.mux.com/video/v1/assets/${videoId}`,
                {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization:
                            "Basic " +
                            Buffer.from(
                                `${credentials?.publicKey}:${credentials?.secretKey}`
                            ).toString("base64"),
                    },
                }
            );

            if (response.ok) {
                const mediaData = await response.json();

                if (mediaData?.data?.master?.status === "ready") {
                    const playbackId = mediaData?.data?.playback_ids?.[0]?.id;
                    const mp4_support = mediaData?.data?.mp4_support || "none";
                    const source_url = mediaData?.data?.master.url;

                    const result = await createMedia(
                        destinationPlatform,
                        playbackId,
                        mp4_support,
                        videoId,
                        source_url
                    );

                    if (result.success) {
                        createdMedia.push(result.response);
                    }
                }
            } else {
                return NextResponse.json(
                    { message: `Error fetching media data for video ID ${videoId}` },
                    { status: 400 }
                );
            }
        }

        return NextResponse.json(
            { success: true, createdMedia },
            { status: 200 }
        );
    } catch (error) {
        return NextResponse.json(
            { message: "Error during media processing" },
            { status: 500 }
        );
    }
}
