interface MetaData {
    environment: string,
    platformId: string
}

interface LogoImage {
    key: null,
    props: Record<string, string>,
    _onwer: string,
    _store: Record<string, string>
}

interface Credentials {
    publicKey: string,
    secretKey: string,
    logo: LogoImage
    additionalMetadata: MetaData
}

interface VideoConfig {
    encodingTier: string,
    playbackPolicy: Array<string>
}

interface PlatformCredentials {
    id: string,
    name: string,
    credentials: Credentials,
    config?: VideoConfig
}


interface Media {
    video_quality: string;
    tracks: Array<Record<string, unknown>>;
    test: boolean;
    status: string;
    resolution_tier: string;
    progress: Record<string, string>;
    playback_ids: Array<Record<string, unknown>>;
    mp4_support: string;
    max_stored_resolution: string;
    max_stored_frame_rate: number;
    max_resolution_tier: string;
    master_access: string;
    master: Record<string, string>;
    ingest_type: string;
    id: string;
    encoding_tier: string;
    duration: number;
    created_at: string;
    aspect_ratio: string;
}

let muxVideosStatusPreparing: Media[] = [];

// get media by id 
const getMedia = async (sourcePlatform: PlatformCredentials, videoId: string) => {
    const credentials = sourcePlatform?.credentials ? sourcePlatform.credentials : null;

    try {

        const response = await fetch(`https://api.mux.com/video/v1/assets/${videoId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Basic ' + Buffer.from(`${credentials?.publicKey ? credentials.publicKey : null}:${credentials?.secretKey ? credentials.secretKey : null}`).toString('base64')
            }
        });

        if (response.ok) {
            const res = await response.json();

            return  {
                success: true,
                response: res
            }

        } else {

            return {success: false, message: "Failed to get media by id mux"}
        }

    } catch (error) {

        return {success: false, message: "Failed to get media by id mux"}
    }
}

// get all mux media of particular workspace
const fetchMuxMedia = async (sourcePlatform: PlatformCredentials) => {
    const credentials = sourcePlatform?.credentials ? sourcePlatform.credentials : null;
    let allVideos: Media[] = [];

    let url = 'https://api.mux.com/video/v1/assets';
    let isMorePages = true;

    try {
        while (isMorePages) {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Basic ' + Buffer.from(`${credentials?.publicKey ? credentials.publicKey : null}:${credentials?.secretKey ? credentials.secretKey : null}`).toString('base64')
                }
            });

            if (response.ok) {
                const res = await response.json();
                const videos = res.data ?? [];

                allVideos = allVideos.concat(videos);

                const nextPage = await res.links?.next;
                if (nextPage) {
                    url = nextPage;
                } else {
                    isMorePages = false;
                }
            } else {
                return { success: false, message: "Failed to get media mux" };
            }
        }

        return {
            success: true,
            response: allVideos
        };

    } catch (error) {
        return { success: false, message: "Failed to get media mux" };
    }
};


// create media in fastpix
const createMedia = async (destinationPlatform: PlatformCredentials, playbackId: string, mp4_support: string, videoId: string) => {
    const credentials = destinationPlatform?.credentials ? destinationPlatform.credentials : null;
    const url = 'https://v1.fastpix.io/on-demand';

    const config = destinationPlatform?.config ? destinationPlatform.config : null;
    const autoGeneratedCaptions = config?.autoGenerateCaptions == "1" ? true : false;
    const maxResolutionTier = config?.maxResolutionTier ? config.maxResolutionTier : null;
    const playbackPolicy = config?.playbackPolicy?.length === 1 ? "public" : "private";
    const testmode = config?.testMode ? config.testMode : null;

    const requestBody = {
        metadata: {
            "muxMediaId": videoId,
        },
        accessPolicy: playbackPolicy,
        maxResolution: maxResolutionTier,
        inputs: [
            {
                type: 'video',
                url: `https://stream.mux.com/${playbackId}/${mp4_support}.mp4`,
                ...(testmode === "1" ? { startTime: 0, endTime: 10 } : {})
            },
        ],
        mp4Support: "capped_4k",
    };
    
    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'Authorization': 'Basic ' + Buffer.from(`${credentials?.publicKey ? credentials.publicKey : null}:${credentials?.secretKey ? credentials.secretKey : null}`).toString('base64')
            },
            body: JSON.stringify(requestBody),
        });

        if (response.ok) {
            const res = await response.json();

            return {
                success: true,
                response: res
            }

        } else {

            return {success: false, message: "Failed to create media in fastpix"}
        }
    } catch (error) {

        return {success: false, message: error?.message ?? "Failed to create media in fastpix"}
    }
};

// get master access for non-mp4 video media
const createMasterAccess = async (sourcePlatform: PlatformCredentials, VideoId: string) => {
    const credentials = sourcePlatform?.credentials ? sourcePlatform.credentials : null;

    const requestBody = {
        "master_access": "temporary"
    }

    try {
        const response = await fetch(`https://api.mux.com/video/v1/assets/${VideoId}/master-access`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Basic ' + Buffer.from(`${credentials?.publicKey ? credentials.publicKey : null}:${credentials?.secretKey ? credentials.secretKey : null}`).toString('base64')
            },
            body: JSON.stringify(requestBody)
        });

        if (response.status === 200) {

            const res =  await response.json();
            return {
                success: true,
                response: res
            }

        } else {

            return { success: false, message: "Failed to get Master Access for Media"};
        }

    } catch (error) {

        return { success: false, message: "Failed to get Master Access for Media" };
    }
}

// on calling migration api from mux to fastpix api
export async function POST(request: Request) {
    const data = await request.json();
    const sourcePlatform = data?.sourcePlatform ? data.sourcePlatform : null;
    const destinationPlatform = data?.destinationPlatform ? data?.destinationPlatform : null;

    const result = await fetchMuxMedia(sourcePlatform);

    if (!result.success) {
        return new Response(JSON.stringify({ success: false, error: 'Failed to fetch media from Mux' }), { status: 400 });
    }
   
    const videos = result?.response ?? []; // all media of mux
    const createdMedia = [];

    for (const video of videos) {
        if (video.mp4_support !== "none") {
            const playbackId = video?.playback_ids?.[0]?.id;
            const mp4_support = video?.mp4_support;
            const videoId = video?.id;
            const passthrough = video?.passthrough ? video.passthrough : null;
           
            const createdMediaItem = await createMedia(destinationPlatform, playbackId, mp4_support, videoId);
            if (createdMediaItem) {
                createdMedia.push(createdMediaItem?.response);
            }

        } else {
            const videoId = video?.id;
            const createdMasterAccess = await createMasterAccess(sourcePlatform, videoId);

            if (createdMasterAccess) {
                const videoId = createdMasterAccess?.response?.data?.id ? createdMasterAccess.response.data.id : null;
                const getMediaById = await getMedia(sourcePlatform, videoId);

                if (getMediaById?.response?.data?.master?.status === "ready") {
                    const source_url = getMediaById?.response?.data?.master?.url;
                    const playbackId = video?.playback_ids?.[0]?.id;
                    const mp4_support = video?.mp4_support;
                    const videoId = video?.id;
                    const passthrough = video?.passthrough ? video.passthrough : null;
                    const createdMediaItem = await createMedia(destinationPlatform, playbackId, mp4_support, videoId, source_url);
                    if (createdMediaItem) {
                        createdMedia.push(createdMediaItem?.response);
                    }
                } else {

                    muxVideosStatusPreparing.push(createdMasterAccess?.response?.data?.id);
                }
            }
        }
    }

    if (createdMedia.length > 0 || muxVideosStatusPreparing.length >= 1) {

        return new Response(JSON.stringify({ success: true, createdMedia, mediaWithPreparingStatus: muxVideosStatusPreparing }), {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
        });
    } else {

        return new Response(JSON.stringify({ success: true, message: 'No media were created' }), { status: 404 });
    }


}
